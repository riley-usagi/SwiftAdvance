//: [Назад](@previous)
import Foundation
// Отсюда и далее мы начнём активно использовать всю мощь ООП (объектно-ориентированного программирования).

// В любом приложении всё состоит из объектов.
// Само приложение - ни что иное как объект, состоящий из иных объектов.

// "Что же такое Объект?" - спросите вы.
// Объект - это экземпляр Класса или Структуры. О классах мы повогорим на следующем уроке,
// а вот о Структураж ниже:

// =================================================================================
// =========================== Structure ===========================================
// =================================================================================

// Структура - это абстрактный тип данных, который может хранить в себе иные данные.
// В том числе и другие структуры.
// Если в двух словах, то: вы можете вынести определённый набор данных и поведения в отдельный объект
// и использовать его в любом месте приложения. Структура по сути своей - это некий чертёж,
// по которому в дальнейшем вы можете создавать однотипные объекты с заранее заданными различиями.

enum skillType {
  case passive, active, offensive
}

/// Наш тестовый монстр
struct Monster {
  let name: String = "Lava Golem"
  var monsterHP: Int = 24324
}

/// Наш герой
struct Player {
  // Свойство структуры. По сути, это та же переменная (или константа в нашем случае),
  // ограниченная лишь областью видимости.
  let skills: (String, skillType) = ("Iron Hand", .passive)
  let heroAtk: Int
  
  // В данном случае мы имеем действие, что наносит определённый урон.
  // Так же стоит заметить, что мы передаём внутрь функции другую структуру по ссылке (inout)
  // Тем самым меняем сам передаваемый объект.
  /// Нанесение урона.
  /// - Parameter monster: Сам объект монстра
  /// - Parameter damage: Урон который наносит герой вышеуказанному монстру
  func takingDamage(monster: inout Monster, damage: Int) {
    monster.monsterHP -= damage
  }
}

var golem: Monster = Monster()
var player: Player = Player(heroAtk: 12478)

player.takingDamage(monster: &golem, damage: player.heroAtk)

// Как видите, количество жизней у монстра уменьшилось.
golem.monsterHP

// =================================================================================
// =========================== Вычисляемые свойства ================================
// =================================================================================

// ASPD = 200-(WD-([WD*AGI/25]+[WD*DEX/100])/10)*(1-SM)

struct Thief {
  var agi: Int
  var dex: Int
  let weapon: String = "Ice Pick"
  let weaponDelay: Float = 50
  var aspd: Float {
    get {
      let agiDelay: Float = (weaponDelay * Float(agi)) / 25
      let dexDelay: Float = (weaponDelay * Float(dex)) / 100
      return 200 - (weaponDelay - ((agiDelay + dexDelay) / 10))
    }
  }
}

var thief = Thief(agi: 34, dex: 15)
thief.aspd

print("\n===========")

// =================================================================================
// =========================== Наблюдатели свойств =================================
// =================================================================================

// Наблюдатели свойств - это блоки кода, которые вызываются, когда свойства меняют свои значения.

struct Knight {
  var berserkStatus: Bool {
    // Вызывается ДО того как значение будет изменено.
    willSet {
      if berserkStatus {
        print("Рыцарь разбушевался! Врассыпную, пацаны!")
      } else {
        print("Фух! Рыцаря отпустило...")
      }
    }
  }
  
  var awakeningStatus: Bool {
    // Вызывается уже ПОСЛЕ того, как значение будет изменено.
    didSet {
      if awakeningStatus {
        print("Рыцарь проснулся.")
      } else {
        print("Спит ещё.")
      }
    }
  }
  
}

var knight = Knight(berserkStatus: false, awakeningStatus: false)
// Поскольку используется willSet - мы видим сообщение от установленного при инициализации значения - false
// Несмотря на то, что по факту сразу после этого наш рыцарь пришёл таки в ярость.
knight.berserkStatus = true

// В случае же с didSet - мы видим сообщение после обновлённого значения - true.
knight.awakeningStatus = true

print("\n===========")

// =================================================================================
// =========================== Методы ==============================================
// =================================================================================

// Методы - это те же функции, только "закреплённые" за Структурами.
// Нам уже доводилось использовать методы ранее в этом уроке. Теперь же рассмотрим их подробнее.

struct Smith {
  var aspd: Float
  
  // Ключевое слово mutating обозначет, что функция меняет свойство самой структуры.
  /// Умение на увеличение скорости атаки.
  mutating func adrenalineRush() {
    aspd += 7
  }
  
  func repairWeapon() -> String {
    return "Оружие и снаряжение снова в порядке!"
  }
}

var smith = Smith(aspd: 163)
smith.adrenalineRush()
smith.aspd
smith.repairWeapon()

print("\n===========\n")

// =================================================================================
// =========================== Конструкторы =======================================
// =================================================================================

// Конструкторы - это специализированные методы, позволяющие создавать экземпляр структуры.

struct BananaHat {
  var name: String
  var reuiredLevel: Int?
  let weight: Int
  var defense: Int
  
  // Мы сами выбираем какие из параметров задать заранее,
  // а какие предоставить на изменение создателю объекта Структуры.
  // Названия для входящих параметров могут быть любыми.
  // Но желаельно делать их похожими на оригинальные названия, дабы избежать путаницы.
  init(def: Int) {
    name = "Banana Hat"
    reuiredLevel = nil
    weight = 20
    
    // В данном случае мы задали несколько свойств заранее,
    // а одно оставили доступным для изменения.
    self.defense = def
  }
}

// Поскольку мы уже задали значения свойств заранее, через инициализатор,
// мы уже не сможем задать их при создании объекта Структуры (за исключением defense).
let bananaHat = BananaHat(def: 1)

// =================================================================================
// =========================== Опциональный конструктор ============================
// =================================================================================

struct Stunner {
  var slots: Int

  // Делаем проверку на отрицательные величины.
  // Если вдруг нам в инициализатор попадёт отрицательное число, то программа не упадёт с ошибкой,
  // а вернёт пустое значение.
  init?(slotsNumber: Int) {
    self.slots = slotsNumber
    guard slots > 0 else {
      return nil
    }
  }
}


let stunner = Stunner(slotsNumber: -2)

// Стоит заметить, что количество инициализаторов не ограничено. Вы можете заранее задать несколько на выбор.

print("\n===========\n")

// =================================================================================
// =========================== Домашнее задание ====================================
// =================================================================================

// Воспользуйтесь получеными знаниями на практике.

//: [Вперёд](@next)
